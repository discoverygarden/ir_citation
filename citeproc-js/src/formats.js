/*
 * Copyright (c) 2009, 2010 and 2011 Frank G. Bennett, Jr. All Rights
 * Reserved.
 *
 * The contents of this file are subject to the Common Public
 * Attribution License Version 1.0 (the “License”); you may not use
 * this file except in compliance with the License. You may obtain a
 * copy of the License at:
 *
 * http://bitbucket.org/fbennett/citeproc-js/src/tip/LICENSE.
 *
 * The License is based on the Mozilla Public License Version 1.1 but
 * Sections 14 and 15 have been added to cover use of software over a
 * computer network and provide for limited attribution for the
 * Original Developer. In addition, Exhibit A has been modified to be
 * consistent with Exhibit B.
 *
 * Software distributed under the License is distributed on an “AS IS”
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the citation formatting software known as
 * "citeproc-js" (an implementation of the Citation Style Language
 * [CSL]), including the original test fixtures and software located
 * under the ./std subdirectory of the distribution archive.
 *
 * The Original Developer is not the Initial Developer and is
 * __________. If left blank, the Original Developer is the Initial
 * Developer.
 *
 * The Initial Developer of the Original Code is Frank G. Bennett,
 * Jr. All portions of the code written by Frank G. Bennett, Jr. are
 * Copyright (c) 2009 and 2010 Frank G. Bennett, Jr. All Rights Reserved.
 *
 * Alternatively, the contents of this file may be used under the
 * terms of the GNU Affero General Public License (the [AGPLv3]
 * License), in which case the provisions of [AGPLv3] License are
 * applicable instead of those above. If you wish to allow use of your
 * version of this file only under the terms of the [AGPLv3] License
 * and not to allow others to use your version of this file under the
 * CPAL, indicate your decision by deleting the provisions above and
 * replace them with the notice and other provisions required by the
 * [AGPLv3] License. If you do not delete the provisions above, a
 * recipient may use your version of this file under either the CPAL
 * or the [AGPLv3] License.”
 */

/*global CSL: true */


/**
 * Output specifications.
 * @class
 */
CSL.Output.Formats = function () {};

/**
 * HTML output format specification.
 * <p>The headline says it all.  The source code for this
 * object can be used as a template for producing other
 * output modes.</p>
 */
CSL.Output.Formats.prototype.html = {
	//
	// text_escape: Format-specific function for escaping text destined
	// for output.  Takes the text to be escaped as sole argument.  Function
	// will be run only once across each portion of text to be escaped, it
	// need not be idempotent.
	//
	"text_escape": function (text) {
		// Numeric entities, in case the output is processed as
		// xml in an environment in which HTML named entities are
		// not declared.
		return text.replace(/&/g, "&#38;")
		.replace(/</g, "&#60;")
		.replace(/>/g, "&#62;")
		.replace("  ", "&#160; ", "g")
		.replace(CSL.SUPERSCRIPTS_REGEXP,
				 function(aChar) {
					 // return "&#60;sup&#62;" + CSL.SUPERSCRIPTS[aChar] + "&#60;/sup&#62;";
					 return "<sup>" + CSL.SUPERSCRIPTS[aChar] + "</sup>";
				 });
	},
	"bibstart": "<div class=\"csl-bib-body\">\n",
	"bibend": "</div>",
	"@font-style/italic": "<i>%%STRING%%</i>",
	"@font-style/oblique": "<em>%%STRING%%</em>",
	"@font-style/normal": "<span style=\"font-style:normal;\">%%STRING%%</span>",
	"@font-variant/small-caps": "<span style=\"font-variant:small-caps;\">%%STRING%%</span>",
	"@passthrough/true": CSL.Output.Formatters.passthrough,
	"@font-variant/normal": "<span style=\"font-variant:normal;\">%%STRING%%</span>",
	"@font-weight/bold": "<b>%%STRING%%</b>",
	"@font-weight/normal": "<span style=\"font-weight:normal;\">%%STRING%%</span>",
	"@font-weight/light": false,
	"@text-decoration/none": "<span style=\"text-decoration:none;\">%%STRING%%</span>",
	"@text-decoration/underline": "<span style=\"text-decoration:underline;\">%%STRING%%</span>",
	"@vertical-align/sup": "<sup>%%STRING%%</sup>",
	"@vertical-align/sub": "<sub>%%STRING%%</sub>",
	"@vertical-align/baseline": "<span style=\"baseline\">%%STRING%%</span>",
	"@strip-periods/true": CSL.Output.Formatters.passthrough,
	"@strip-periods/false": CSL.Output.Formatters.passthrough,
	"@quotes/true": function (state, str) {
		if ("undefined" === typeof str) {
			return state.getTerm("open-quote");
		}
		return state.getTerm("open-quote") + str + state.getTerm("close-quote");
	},
	"@quotes/inner": function (state, str) {
		if ("undefined" === typeof str) {
			//
			// Mostly right by being wrong (for apostrophes)
			//
			return "\u2019";
		}
		return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
	},
	"@quotes/false": false,
	//"@bibliography/body": function (state,str){
	//	return "<div class=\"csl-bib-body\">\n"+str+"</div>";
	//},
	"@bibliography/entry": function (state, str) {
		// Test for this.item_id to add decorations to
		// bibliography output of individual entries.
		//
		// Full item content can be obtained from
		// state.registry.registry[id].ref, using
		// CSL variable keys.
		//
		// Example:
		//
		//   print(state.registry.registry[this.item_id].ref["title"]);
		//
		// At present, for parallel citations, only the
		// id of the master item is supplied on this.item_id.
		var insert = "";
		if (state.sys.embedBibliographyEntry) {
			insert = state.sys.embedBibliographyEntry(this.item_id) + "\n";
		}
		return "  <div class=\"csl-entry\">" + str + "</div>\n" + insert;
	},
	"@display/block": function (state, str) {
		return "\n\n    <div class=\"csl-block\">" + str + "</div>\n";
	},
	"@display/left-margin": function (state, str) {
		return "\n    <div class=\"csl-left-margin\">" + str + "</div>";
	},
	"@display/right-inline": function (state, str) {
		return "<div class=\"csl-right-inline\">" + str + "</div>\n  ";
	},
	"@display/indent": function (state, str) {
		return "<div class=\"csl-indent\">" + str + "</div>\n  ";
	}
};

/**
 * Plain text output specification.
 *
 * (Code contributed by Simon Kornblith, Center for History and New Media,
 * George Mason University.)
 */
CSL.Output.Formats.prototype.text = {
	//
	// text_escape: Format-specific function for escaping text destined
	// for output.  Takes the text to be escaped as sole argument.  Function
	// will be run only once across each portion of text to be escaped, it
	// need not be idempotent.
	//
	"text_escape": function (text) {
		return text;
	},
	"bibstart": "",
	"bibend": "",
	"@font-style/italic": false,
	"@font-style/oblique": false,
	"@font-style/normal": false,
	"@font-variant/small-caps": false,
	"@passthrough/true": CSL.Output.Formatters.passthrough,
	"@font-variant/normal": false,
	"@font-weight/bold": false,
	"@font-weight/normal": false,
	"@font-weight/light": false,
	"@text-decoration/none": false,
	"@text-decoration/underline": false,
	"@vertical-align/baseline": false,
	"@vertical-align/sup": false,
	"@vertical-align/sub": false,
	"@strip-periods/true": CSL.Output.Formatters.passthrough,
	"@strip-periods/false": CSL.Output.Formatters.passthrough,
	"@quotes/true": function (state, str) {
		if ("undefined" === typeof str) {
			return state.getTerm("open-quote");
		}
		return state.getTerm("open-quote") + str + state.getTerm("close-quote");
	},
	"@quotes/inner": function (state, str) {
		if ("undefined" === typeof str) {
			//
			// Mostly right by being wrong (for apostrophes)
			//
			return "\u2019";
		}
		return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
	},
	"@quotes/false": false,
	//"@bibliography/body": function (state,str){
	//	return "<div class=\"csl-bib-body\">\n"+str+"</div>";
	//},
	"@bibliography/entry": function (state, str) {
		return str+"\n";
	},
	"@display/block": function (state, str) {
		return "\n"+str;
	},
	"@display/left-margin": function (state, str) {
		return str;
	},
	"@display/right-inline": function (state, str) {
		return str;
	},
	"@display/indent": function (state, str) {
		return "\n    "+str;
	}
};

/**
 * Plain text output specification.
 *
 * (Code contributed by Simon Kornblith, Center for History and New Media,
 * George Mason University.)
 */
CSL.Output.Formats.prototype.rtf = {
	//
	// text_escape: Format-specific function for escaping text destined
	// for output.  Takes the text to be escaped as sole argument.  Function
	// will be run only once across each portion of text to be escaped, it
	// need not be idempotent.
	//
	"text_escape": function (text) {
		return text
		.replace(/([\\{}])/g, "\\$1", "g")
		.replace(CSL.SUPERSCRIPTS_REGEXP,
				 function(aChar) {
					 return "\\super " + CSL.SUPERSCRIPTS[aChar] + "\\nosupersub{}";
				 })
		.replace(/[\x7F-\uFFFF]/g,
				 function(aChar) { return "\\uc0\\u"+aChar.charCodeAt(0).toString()+"{}" })
		.replace("\t", "\\tab{}", "g");
	},
	"@passthrough/true": CSL.Output.Formatters.passthrough,
	"@font-style/italic":"\\i %%STRING%%\\i0{}",
	"@font-style/normal":"\\i0{}%%STRING%%\\i{}",
	"@font-style/oblique":"\\i %%STRING%%\\i0{}",
	"@font-variant/small-caps":"\\scaps %%STRING%%\\scaps0{}",
	"@font-variant/normal":"\\scaps0{}%%STRING%%\\scaps{}",
	"@font-weight/bold":"\\b %%STRING%%\\b0{}",
	"@font-weight/normal":"\\b0{}%%STRING%%\\b{}",
	"@font-weight/light":false,
	"@text-decoration/none":false,
	"@text-decoration/underline":"\\ul %%STRING%%\\ul0{}",
	"@vertical-align/baseline":false,
	"@vertical-align/sup":"\\super %%STRING%%\\nosupersub{}",
	"@vertical-align/sub":"\\sub %%STRING%%\\nosupersub{}",
	"@strip-periods/true": CSL.Output.Formatters.passthrough,
	"@strip-periods/false": CSL.Output.Formatters.passthrough,
	"@quotes/true": function (state, str) {
		if ("undefined" === typeof str) {
			return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote"));
		}
		return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote")) + str + CSL.Output.Formats.rtf.text_escape(state.getTerm("close-quote"));
	},
	"@quotes/inner": function (state, str) {
		if ("undefined" === typeof str) {
			return CSL.Output.Formats.rtf.text_escape("\u2019");
		}
		return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-inner-quote")) + str + CSL.Output.Formats.rtf.text_escape(state.getTerm("close-inner-quote"));
	},
	"@quotes/false": false,
	"bibstart":"{\\rtf ",
	"bibend":"}",
	"@display/block":"%%STRING%%\\line\r\n",
	"@bibliography/entry": function(state,str){
		return str;
	},
	"@display/left-margin": function(state,str){
		return str+"\\tab ";
	},
	"@display/right-inline": function (state, str) {
		return str+"\n";
	},
	"@display/indent": function (state, str) {
		return "\n\\tab "+str;
	}
};

CSL.Output.Formats = new CSL.Output.Formats();
